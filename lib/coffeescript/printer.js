// Generated by CoffeeScript 2.3.1
(function() {
  var BLOCK, CodeFragment, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, SIMPLENUM, TAB, _dump, asStatement, del, dump, extend, flatten, fragmentize, fragmentsToText, indent, isArray, isString, makeCode, merge, needsParens, nodePrint, print, printArray, printAssignment, printBinaryExpression, printBlock, printCall, printObject, printParams, printStatementSequence, printer, wrapInBraces, wrapInParensIfAbove,
    indexOf = [].indexOf;

  ({
    merge,
    dump: _dump,
    extend,
    isString,
    isArray,
    del,
    flatten
  } = require('./helpers'));

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref;
      this.code = `${code}`;
      this.type = (parent != null ? (ref = parent.constructor) != null ? ref.name : void 0 : void 0) || 'unknown';
      this.locationData = parent != null ? parent.locationData : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }

    toString() {
      // This is only intended for debugging.
      return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
    }

  };

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = fragments.length; i < len; i++) {
        fragment = fragments[i];
        results.push(fragment.code);
      }
      return results;
    })()).join('');
  };

  printStatementSequence = function(body, o) {
    var fragments, i, index, len, stmt;
    // TODO: directives
    fragments = [];
    for (index = i = 0, len = body.length; i < len; index = ++i) {
      stmt = body[index];
      if (index && o.spaced) {
        fragments.push('\n');
      }
      fragments.push(...this.print(stmt, merge(o, {
        spaced: false,
        front: true,
        asStatement: true,
        level: LEVEL_TOP
      })));
    }
    return fragments;
  };

  BLOCK = ['IfStatement', 'ForStatement', 'ForInStatement', 'WhileStatement', 'ClassStatement', 'TryStatement', 'SwitchStatement'];

  asStatement = function(fragments, o) {
    var ref;
    fragments.unshift(o.indent);
    if (ref = this.type, indexOf.call(BLOCK, ref) < 0) {
      fragments.push(';');
    }
    fragments.push('\n');
    return fragments;
  };

  wrapInParensIfAbove = function(level) {
    return function(fragments, o) {
      if (!(o.level > level)) {
        return fragments;
      }
      return [this.makeCode('('), ...fragments, this.makeCode(')')];
    };
  };

  wrapInBraces = function(fragments, o) {
    return ['{', ...fragments, '}'];
  };

  printAssignment = function(o) {
    var fragments, ref;
    fragments = [];
    fragments.push(...this.print(this.left, o, LEVEL_LIST));
    fragments.push(` ${(ref = this.operator) != null ? ref : '='} `);
    fragments.push(...this.print(this.right, o, LEVEL_LIST));
    return fragments;
  };

  printObject = function(o) {
    var fragments, i, index, isCompact, j, len, len1, prop, ref, ref1, shorthand;
    fragments = [];
    isCompact = true;
    ref = this.properties;
    for (i = 0, len = ref.length; i < len; i++) {
      ({shorthand} = ref[i]);
      if (!(!shorthand)) {
        continue;
      }
      isCompact = false;
      break;
    }
    if (!isCompact) {
      fragments.push('\n');
    }
    ref1 = this.properties;
    for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
      prop = ref1[index];
      if (index) {
        fragments.push(',');
        fragments.push(isCompact ? ' ' : '\n');
      }
      if (!isCompact) {
        fragments.push(o.indent + TAB);
      }
      fragments.push(...this.print(prop, isCompact ? o : indent(o)));
    }
    if (!isCompact) {
      fragments.push('\n' + o.indent);
    }
    return this.wrapInBraces(fragments);
  };

  printBinaryExpression = function(o) {
    var fragments;
    fragments = [];
    fragments.push(...this.print(this.left, o, LEVEL_OP));
    fragments.push(` ${this.operator} `);
    fragments.push(...this.print(this.right, o, LEVEL_OP));
    return fragments;
  };

  printCall = function(o) {
    var arg, fragments, i, index, len, ref;
    fragments = [];
    if (this.type === 'NewExpression') {
      fragments.push('new ');
    }
    fragments.push(...this.print(this.callee, o, LEVEL_ACCESS));
    fragments.push('(');
    ref = this.arguments;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      arg = ref[index];
      if (index) {
        fragments.push(', ');
      }
      fragments.push(...this.print(arg, o, LEVEL_LIST));
    }
    fragments.push(')');
    return fragments;
  };

  printArray = function(o) {
    var element, fragments, i, index, len, ref;
    if (!this.elements.length) {
      return ['[]'];
    }
    fragments = [];
    fragments.push('[');
    ref = this.elements;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      element = ref[index];
      if (index) {
        fragments.push(', ');
      }
      fragments.push(...this.print(element, o));
    }
    fragments.push(']');
    return fragments;
  };

  printParams = function(o) {
    var fragments, i, index, len, param, ref;
    fragments = [];
    fragments.push('(');
    ref = this.params;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      param = ref[index];
      if (index) {
        fragments.push(', ');
      }
      fragments.push(...this.print(param, o));
    }
    fragments.push(') ');
    return fragments;
  };

  printBlock = function(o) {
    var body, fragments;
    if (!this.body.length) {
      return ['{}'];
    }
    fragments = [];
    fragments.push('{');
    fragments.push('\n');
    body = this.printStatementSequence(this.body, indent(o));
    fragments.push(...body);
    fragments.push(o.indent + '}');
    return fragments;
  };

  printer = {
    File: function(o) {
      o.indent = o.bare ? '' : TAB;
      o.spaced = true;
      return this.print(this.program, o);
    },
    Program: function(o) {
      return this.printStatementSequence(this.body, o);
    },
    VariableDeclaration: function(o) {
      var declaration, fragments, i, index, len, ref;
      fragments = ['var '];
      ref = this.declarations;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        declaration = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(declaration, o));
      }
      return fragments;
    },
    VariableDeclarator: function(o) {
      var fragments;
      fragments = [];
      fragments.push(...this.print(this.id, o));
      if (this.init) {
        fragments.push(' = ');
        fragments.push(...this.print(this.init, o));
      }
      return fragments;
    },
    ExpressionStatement: function(o) {
      return this.print(this.expression, o);
    },
    AssignmentExpression: printAssignment,
    AssignmentPattern: printAssignment,
    Identifier: function(o) {
      return [this.name];
    },
    NumericLiteral: function(o) {
      return [this.extra.raw];
    },
    StringLiteral: function(o) {
      return [this.extra.raw];
    },
    RegExpLiteral: function(o) {
      return [this.extra.raw];
    },
    BooleanLiteral: function(o) {
      return [this.value ? 'true' : 'false'];
    },
    NullLiteral: function(o) {
      return ['null'];
    },
    ThisExpression: function(o) {
      return ['this'];
    },
    Super: function(o) {
      return ['super'];
    },
    NewExpression: printCall,
    CallExpression: printCall,
    FunctionExpression: function(o) {
      var fragments;
      fragments = [];
      if (this.async) {
        fragments.push('async ');
      }
      fragments.push('function');
      fragments.push(...this.printParams(o));
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    ArrowFunctionExpression: function(o) {
      var fragments;
      fragments = [];
      if (this.async) {
        fragments.push('async ');
      }
      fragments.push(...this.printParams(o));
      fragments.push('=> ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    ClassMethod: function(o) {
      var fragments;
      fragments = [];
      if (this.static) {
        fragments.push('static ');
      }
      if (this.async) {
        fragments.push('async ');
      }
      fragments.push(...this.print(this.key, o));
      fragments.push(...this.printParams(o));
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    BlockStatement: printBlock,
    ReturnStatement: function(o) {
      var fragments;
      fragments = ['return'];
      if (this.argument) {
        fragments.push(' ', ...this.print(this.argument, o, LEVEL_PAREN));
      }
      return fragments;
    },
    MemberExpression: function(o) {
      var fragments, property;
      fragments = [];
      fragments.push(...this.print(this.object, o, LEVEL_ACCESS));
      property = this.print(this.property, o);
      if (SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push('.');
      }
      if (this.computed) {
        fragments.push('[', ...property, ']');
      } else {
        fragments.push('.', ...property);
      }
      return fragments;
    },
    ObjectPattern: printObject,
    ObjectExpression: printObject,
    ObjectProperty: function(o) {
      var fragments, key;
      fragments = [];
      key = this.print(this.key, o);
      if (this.shorthand) {
        return key;
      }
      if (this.computed) {
        fragments.push('[');
      }
      fragments.push(...key);
      if (this.computed) {
        fragments.push(']');
      }
      fragments.push(': ');
      fragments.push(...this.print(this.value, o));
      return fragments;
    },
    ArrayExpression: printArray,
    ArrayPattern: printArray,
    TemplateLiteral: function(o) {
      var expression, fragments, i, index, len, quasi, ref;
      fragments = [];
      fragments.push('`');
      ref = this.quasis;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        quasi = ref[index];
        fragments.push(...this.print(quasi, o));
        expression = this.expressions[index];
        if (expression) {
          fragments.push('${');
          fragments.push(...this.print(expression, o));
          fragments.push('}');
        }
      }
      fragments.push('`');
      return fragments;
    },
    TemplateElement: function(o) {
      return [this.value.raw];
    },
    ForStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('for (');
      fragments.push(...this.print(this.init, o));
      fragments.push('; ');
      fragments.push(...this.print(this.test, o));
      fragments.push('; ');
      fragments.push(...this.print(this.update, o));
      fragments.push(') ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    ForInStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('for (');
      fragments.push(...this.print(this.left, o));
      fragments.push(' in ');
      fragments.push(...this.print(this.right, o));
      fragments.push(') ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    SequenceExpression: function(o) {
      var expression, fragments, i, index, len, ref;
      fragments = [];
      ref = this.expressions;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        expression = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(expression, o));
      }
      return fragments;
    },
    BinaryExpression: printBinaryExpression,
    LogicalExpression: printBinaryExpression,
    UnaryExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push(this.operator);
      if (/[a-z]$/.test(this.operator)) {
        fragments.push(' ');
      }
      fragments.push(...this.print(this.argument, o));
      return fragments;
    },
    UpdateExpression: function(o) {
      var fragments;
      fragments = [];
      if (this.prefix) {
        fragments.push(this.operator);
      }
      fragments.push(...this.print(this.argument, o));
      if (!this.prefix) {
        fragments.push(this.operator);
      }
      return fragments;
    },
    IfStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('if (');
      fragments.push(...print(this.test, o));
      fragments.push(') ');
      fragments.push(...print(this.consequent, o));
      if (this.alternate) {
        fragments.push(' else ');
        fragments.push(...print(this.alternate, o));
      }
      return fragments;
    },
    ConditionalExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push(...print(this.test, o));
      fragments.push(' ? ');
      fragments.push(...print(this.consequent, o));
      fragments.push(' : ');
      fragments.push(...print(this.alternate, o));
      return fragments;
    },
    ContinueStatement: function(o) {
      return ['continue'];
    },
    BreakStatement: function(o) {
      return ['break'];
    },
    AwaitExpression: function(o) {
      var fragments;
      fragments = ['await '];
      fragments.push(...this.print(this.argument, o));
      return fragments;
    },
    SwitchStatement: function(o) {
      var fragments, i, kase, len, ref;
      fragments = ['switch ('];
      fragments.push(...this.print(this.discriminant, o));
      fragments.push(') {\n');
      ref = this.cases;
      for (i = 0, len = ref.length; i < len; i++) {
        kase = ref[i];
        fragments.push(...this.print(kase, indent(o)));
      }
      fragments.push('}');
      return fragments;
    },
    SwitchCase: function(o) {
      var fragments;
      fragments = [];
      fragments.push(o.indent);
      if (this.test) {
        fragments.push('case ');
        fragments.push(...this.print(this.test, o));
      } else {
        fragments.push('default');
      }
      fragments.push(':');
      fragments.push('\n');
      fragments.push(...this.printStatementSequence(this.consequent, indent(o)));
      return fragments;
    },
    TryStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('try ');
      fragments.push(...this.print(this.block, o));
      if (this.handler) {
        fragments.push(' ', ...this.print(this.handler, o));
      }
      return fragments;
    },
    CatchClause: function(o) {
      var fragments;
      fragments = [];
      fragments.push('catch (');
      fragments.push(...this.print(this.param, o));
      fragments.push(') ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    ThrowStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('throw ');
      fragments.push(...this.print(this.argument, o));
      return fragments;
    },
    ClassExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push('class');
      if (this.id) {
        fragments.push(' ');
        fragments.push(...this.print(this.id, o));
      }
      if (this.superClass) {
        fragments.push(' extends ');
        fragments.push(...this.print(this.superClass, o));
      }
      if (this.body) {
        fragments.push(' ');
        fragments.push(...this.print(this.body, o));
      }
      return fragments;
    },
    ClassBody: function(o) {
      return printBlock.call(this, merge(o, {
        spaced: true
      }));
    }
  };

  makeCode = function(code) {
    return new CodeFragment(this, code);
  };

  fragmentize = function(fragments, node) {
    var fragment, i, len, results;
    results = [];
    for (i = 0, len = fragments.length; i < len; i++) {
      fragment = fragments[i];
      if (isString(fragment)) {
        results.push(node.makeCode(fragment));
      } else {
        results.push(fragment);
      }
    }
    return results;
  };

  nodePrint = function(node, o, level) {
    var printed;
    if (level) {
      o = merge(o, {level});
    }
    // return flatten(@print child, o for child in node) if isArray node
    node.parent = this;
    printed = fragmentize(print(node, merge(o, {
      front: false
    })), node);
    if (!needsParens(node, o)) {
      return printed;
    }
    return [node.makeCode('('), ...printed, node.makeCode(')')];
  };

  exports.print = print = function(node, o) {
    var _asStatement, printed;
    _asStatement = del(o, 'asStatement');
    extend(node, {
      makeCode,
      printStatementSequence,
      wrapInBraces,
      asStatement,
      printParams,
      print: nodePrint
    });
    if (!printer[node.type]) {
      // node.tab = o.indent
      console.log({
        missing: node
      });
    }
    printed = printer[node.type].call(node, o);
    if (!_asStatement) {
      return printed;
    }
    return node.asStatement(printed, o);
  };

  indent = function(o) {
    return merge(o, {
      indent: o.indent + TAB
    });
  };

  TAB = '  ';

  SIMPLENUM = /^[+-]?\d+$/;

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  needsParens = function(node, o) {
    var level, parent, type;
    ({type, parent} = node);
    ({level} = o);
    if (o.front && ((type === 'FunctionExpression' || type === 'ObjectExpression') || type === 'AssignmentExpression' && node.left.type === 'ObjectPattern')) {
      return true;
    }
    switch (type) {
      case 'AssignmentExpression':
        if (level > LEVEL_LIST) {
          return true;
        }
        if (node.left.type === 'ObjectPattern') {
          return true;
        }
        switch (parent.type) {
          case 'ReturnStatement':
            return true;
        }
        break;
      case 'FunctionExpression':
      case 'ArrowFunctionExpression':
        if (level >= LEVEL_ACCESS) {
          return true;
        }
        break;
      case 'BinaryExpression':
        if (parent.type === 'BinaryExpression' && node === parent.right) {
          return true;
        }
        if (parent.type === 'UnaryExpression') {
          return true;
        }
        break;
      case 'AwaitExpression':
        if (level >= LEVEL_PAREN) {
          return true;
        }
    }
  };

  dump = function(obj) {
    return _dump(merge(obj, {
      parent: null
    }));
  };

}).call(this);
