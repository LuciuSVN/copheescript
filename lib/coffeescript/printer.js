// Generated by CoffeeScript 2.3.1
(function() {
  var CodeFragment, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, SIMPLENUM, TAB, _dump, asStatement, del, dump, extend, fragmentize, fragmentsToText, indent, isString, makeCode, merge, needsParens, nodePrint, print, printAssignment, printBinaryExpression, printObject, printStatementSequence, printer, wrapInBraces, wrapInParensIfAbove;

  ({
    merge,
    dump: _dump,
    extend,
    isString,
    del
  } = require('./helpers'));

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref;
      this.code = `${code}`;
      this.type = (parent != null ? (ref = parent.constructor) != null ? ref.name : void 0 : void 0) || 'unknown';
      this.locationData = parent != null ? parent.locationData : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }

    toString() {
      // This is only intended for debugging.
      return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
    }

  };

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = fragments.length; i < len; i++) {
        fragment = fragments[i];
        results.push(fragment.code);
      }
      return results;
    })()).join('');
  };

  printStatementSequence = function(body, o) {
    var fragments, i, index, len, stmt;
    // o = merge o, level: LEVEL_TOP
    // TODO: directives
    fragments = [];
    for (index = i = 0, len = body.length; i < len; index = ++i) {
      stmt = body[index];
      if (index && o.spaced) {
        fragments.push('\n');
      }
      fragments.push(...this.print(stmt, merge(o, {
        spaced: false,
        front: true,
        asStatement: true
      })));
    }
    return fragments;
  };

  asStatement = function(fragments, o) {
    fragments.unshift(o.indent);
    fragments.push(';\n');
    return fragments;
  };

  wrapInParensIfAbove = function(level) {
    return function(fragments, o) {
      if (!(o.level > level)) {
        return fragments;
      }
      return [this.makeCode('('), ...fragments, this.makeCode(')')];
    };
  };

  wrapInBraces = function(fragments, o) {
    return ['{', ...fragments, '}'];
  };

  printAssignment = function(o) {
    var fragments, ref;
    fragments = [];
    fragments.push(...this.print(this.left, o));
    fragments.push(` ${(ref = this.operator) != null ? ref : '='} `);
    fragments.push(...this.print(this.right, o));
    return fragments;
  };

  printObject = function(o) {
    var fragments, i, index, isCompact, j, len, len1, prop, ref, ref1, shorthand;
    fragments = [];
    isCompact = true;
    ref = this.properties;
    for (i = 0, len = ref.length; i < len; i++) {
      ({shorthand} = ref[i]);
      if (!(!shorthand)) {
        continue;
      }
      isCompact = false;
      break;
    }
    if (!isCompact) {
      fragments.push('\n');
    }
    ref1 = this.properties;
    for (index = j = 0, len1 = ref1.length; j < len1; index = ++j) {
      prop = ref1[index];
      if (index) {
        fragments.push(',');
        fragments.push(isCompact ? ' ' : '\n');
      }
      if (!isCompact) {
        fragments.push(o.indent + TAB);
      }
      fragments.push(...this.print(prop, isCompact ? o : indent(o)));
    }
    if (!isCompact) {
      fragments.push('\n' + o.indent);
    }
    return this.wrapInBraces(fragments);
  };

  printBinaryExpression = function(o) {
    var fragments;
    fragments = [];
    fragments.push(...this.print(this.left, o, LEVEL_OP));
    fragments.push(` ${this.operator} `);
    fragments.push(...this.print(this.right, o, LEVEL_OP));
    return fragments;
  };

  printer = {
    File: function(o) {
      o.indent = o.bare ? '' : TAB;
      o.spaced = true;
      return this.print(this.program, o);
    },
    Program: function(o) {
      return this.printStatementSequence(this.body, o);
    },
    VariableDeclaration: function(o) {
      var declaration, fragments, i, index, len, ref;
      fragments = ['var '];
      ref = this.declarations;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        declaration = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(declaration, o));
      }
      return fragments;
    },
    VariableDeclarator: function(o) {
      var fragments;
      fragments = [];
      fragments.push(...this.print(this.id, o));
      if (this.init) {
        fragments.push(' = ');
        fragments.push(...this.print(this.init, o));
      }
      return fragments;
    },
    ExpressionStatement: function(o) {
      return this.print(this.expression, merge(o, {
        front: true
      }));
    },
    AssignmentExpression: printAssignment,
    AssignmentPattern: printAssignment,
    Identifier: function(o) {
      return [this.name];
    },
    NumericLiteral: function(o) {
      return [this.extra.raw];
    },
    StringLiteral: function(o) {
      return [this.extra.raw];
    },
    RegExpLiteral: function(o) {
      return [this.extra.raw];
    },
    BooleanLiteral: function(o) {
      return [this.value ? 'true' : 'false'];
    },
    NullLiteral: function(o) {
      return ['null'];
    },
    ThisExpression: function(o) {
      return ['this'];
    },
    CallExpression: function(o) {
      var arg, fragments, i, index, len, ref;
      fragments = [];
      fragments.push(...this.print(this.callee, o, LEVEL_ACCESS));
      fragments.push('(');
      ref = this.arguments;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        arg = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(arg, o));
      }
      fragments.push(')');
      return fragments;
    },
    FunctionExpression: function(o) {
      var fragments, i, index, len, param, ref;
      fragments = [];
      fragments.push('function');
      fragments.push('(');
      ref = this.params;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        param = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(param, o));
      }
      fragments.push(')');
      fragments.push(' ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    BlockStatement: function(o) {
      var body, fragments;
      if (!this.body.length) {
        return ['{}'];
      }
      fragments = [];
      fragments.push('{');
      fragments.push('\n');
      body = this.printStatementSequence(this.body, indent(o));
      fragments.push(...body);
      fragments.push(o.indent + '}');
      return fragments;
    },
    ReturnStatement: function(o) {
      var fragments;
      fragments = ['return'];
      if (this.argument) {
        fragments.push(' ', ...this.print(this.argument, o));
      }
      return fragments;
    },
    MemberExpression: function(o) {
      var fragments, property;
      fragments = [];
      fragments.push(...this.print(this.object, o, LEVEL_ACCESS));
      property = this.print(this.property, o);
      if (SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push('.');
      }
      if (this.computed) {
        fragments.push('[', ...property, ']');
      } else {
        fragments.push('.', ...property);
      }
      return fragments;
    },
    ObjectPattern: printObject,
    ObjectExpression: printObject,
    ObjectProperty: function(o) {
      var fragments, key;
      fragments = [];
      key = this.print(this.key, o);
      if (this.shorthand) {
        return key;
      }
      if (this.computed) {
        fragments.push('[');
      }
      fragments.push(...key);
      if (this.computed) {
        fragments.push(']');
      }
      fragments.push(': ');
      fragments.push(...this.print(this.value, o));
      return fragments;
    },
    ArrayExpression: function(o) {
      var element, fragments, i, index, len, ref;
      if (!this.elements.length) {
        return ['[]'];
      }
      fragments = [];
      fragments.push('[');
      ref = this.elements;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        element = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(element, o));
      }
      fragments.push(']');
      return fragments;
    },
    TemplateLiteral: function(o) {
      var expression, fragments, i, index, len, quasi, ref;
      fragments = [];
      fragments.push('`');
      ref = this.quasis;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        quasi = ref[index];
        fragments.push(...this.print(quasi, o));
        expression = this.expressions[index];
        if (expression) {
          fragments.push('${');
          fragments.push(...this.print(expression, o));
          fragments.push('}');
        }
      }
      fragments.push('`');
      return fragments;
    },
    TemplateElement: function(o) {
      return [this.value.raw];
    },
    ForStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('for (');
      fragments.push(...this.print(this.init, o));
      fragments.push('; ');
      fragments.push(...this.print(this.test, o));
      fragments.push('; ');
      fragments.push(...this.print(this.update, o));
      fragments.push(') ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    ForInStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('for (');
      fragments.push(...this.print(this.left, o));
      fragments.push(' in ');
      fragments.push(...this.print(this.right, o));
      fragments.push(') ');
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    SequenceExpression: function(o) {
      var expression, fragments, i, index, len, ref;
      fragments = [];
      ref = this.expressions;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        expression = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(expression, o));
      }
      return fragments;
    },
    BinaryExpression: printBinaryExpression,
    LogicalExpression: printBinaryExpression,
    UnaryExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push(this.operator);
      if (/[a-z]$/.test(this.operator)) {
        fragments.push(' ');
      }
      fragments.push(...this.print(this.argument, o));
      return fragments;
    },
    UpdateExpression: function(o) {
      var fragments;
      fragments = [];
      if (this.prefix) {
        fragments.push(this.operator);
      }
      fragments.push(...this.print(this.argument, o));
      if (!this.prefix) {
        fragments.push(this.operator);
      }
      return fragments;
    },
    IfStatement: function(o) {
      var fragments;
      fragments = [];
      fragments.push('if (');
      fragments.push(...print(this.test, o));
      fragments.push(') ');
      fragments.push(...print(this.consequent, o));
      if (this.alternate) {
        fragments.push(' else ');
        fragments.push(...print(this.alternate, o));
      }
      return fragments;
    },
    ConditionalExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push(...print(this.test, o));
      fragments.push(' ? ');
      fragments.push(...print(this.consequent, o));
      fragments.push(' : ');
      fragments.push(...print(this.alternate, o));
      return fragments;
    },
    ContinueStatement: function(o) {
      return ['continue'];
    }
  };

  makeCode = function(code) {
    return new CodeFragment(this, code);
  };

  fragmentize = function(fragments, node) {
    var fragment, i, len, results;
    results = [];
    for (i = 0, len = fragments.length; i < len; i++) {
      fragment = fragments[i];
      if (isString(fragment)) {
        results.push(node.makeCode(fragment));
      } else {
        results.push(fragment);
      }
    }
    return results;
  };

  nodePrint = function(node, o, level) {
    var printed;
    if (level) {
      o = merge(o, {level});
    }
    node.parent = this;
    printed = fragmentize(print(node, merge(o, {
      front: false
    })), node);
    if (!needsParens(node, o)) {
      return printed;
    }
    return [node.makeCode('('), ...printed, node.makeCode(')')];
  };

  exports.print = print = function(node, o) {
    var _asStatement, printed;
    _asStatement = del(o, 'asStatement');
    extend(node, {
      makeCode,
      printStatementSequence,
      wrapInBraces,
      asStatement,
      print: nodePrint
    });
    if (!printer[node.type]) {
      // node.tab = o.indent
      console.log({
        missing: node
      });
    }
    printed = printer[node.type].call(node, o);
    if (!_asStatement) {
      return printed;
    }
    return node.asStatement(printed, o);
  };

  indent = function(o) {
    return merge(o, {
      indent: o.indent + TAB
    });
  };

  TAB = '  ';

  SIMPLENUM = /^[+-]?\d+$/;

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  needsParens = function(node, o) {
    var level, parent, type;
    ({type, parent} = node);
    ({level} = o);
    if (o.front && ((type === 'FunctionExpression' || type === 'ObjectExpression') || type === 'AssignmentExpression' && node.left.type === 'ObjectPattern')) {
      return true;
    }
    switch (type) {
      case 'AssignmentExpression':
        if (level > LEVEL_LIST) {
          return true;
        }
        switch (parent.type) {
          case 'ReturnStatement':
            return true;
        }
        break;
      case 'FunctionExpression':
        if (level >= LEVEL_ACCESS) {
          return true;
        }
        break;
      case 'BinaryExpression':
        if (parent.type === 'BinaryExpression' && node === parent.right) {
          return true;
        }
        if (parent.type === 'UnaryExpression') {
          return true;
        }
    }
  };

  dump = function(obj) {
    return _dump(merge(obj, {
      parent: null
    }));
  };

}).call(this);
