// Generated by CoffeeScript 2.3.1
(function() {
  var CodeFragment, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, TAB, _dump, asStatement, dump, extend, indent, makeCode, merge, needsParens, nodePrint, print, printStatementSequence, printer, wrapInParensIfAbove;

  ({
    merge,
    dump: _dump,
    extend
  } = require('./helpers'));

  //### CodeFragment

  // The various nodes defined below all compile to a collection of **CodeFragment** objects.
  // A CodeFragments is a block of generated code, and the location in the source file where the code
  // came from. CodeFragments can be assembled together into working code just by catting together
  // all the CodeFragments' `code` snippets, in order.
  exports.CodeFragment = CodeFragment = class CodeFragment {
    constructor(parent, code) {
      var ref;
      this.code = `${code}`;
      this.type = (parent != null ? (ref = parent.constructor) != null ? ref.name : void 0 : void 0) || 'unknown';
      this.locationData = parent != null ? parent.locationData : void 0;
      this.comments = parent != null ? parent.comments : void 0;
    }

    toString() {
      // This is only intended for debugging.
      return `${this.code}${this.locationData ? ": " + locationDataToString(this.locationData) : ''}`;
    }

  };

  printStatementSequence = function(body, o) {
    var fragments, i, index, len, stmt;
    // o = merge o, level: LEVEL_TOP
    // TODO: directives
    fragments = [];
    for (index = i = 0, len = body.length; i < len; index = ++i) {
      stmt = body[index];
      if (index && o.spaced) {
        fragments.push(this.makeCode('\n'));
      }
      fragments.push(...this.print(stmt, merge(o, {
        spaced: false,
        front: true
      })));
    }
    return fragments;
  };

  asStatement = function(fragments, o) {
    fragments.unshift(this.makeCode(o.indent));
    fragments.push(this.makeCode(';\n'));
    return fragments;
  };

  wrapInParensIfAbove = function(level) {
    return function(fragments, o) {
      if (!(o.level > level)) {
        return fragments;
      }
      return [this.makeCode('('), ...fragments, this.makeCode(')')];
    };
  };

  printer = {
    File: function(o) {
      o.indent = o.bare ? '' : TAB;
      o.spaced = true;
      return this.print(this.program, o);
    },
    Program: function(o) {
      return this.printStatementSequence(this.body, o);
    },
    VariableDeclaration: function(o) {
      var declaration, fragments, i, index, len, ref;
      fragments = [this.makeCode('var ')];
      ref = this.declarations;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        declaration = ref[index];
        if (index) {
          fragments.push(', ');
        }
        fragments.push(...this.print(declaration, o));
      }
      return this.asStatement(fragments, o);
    },
    VariableDeclarator: function(o) {
      return this.print(this.id, o);
    },
    ExpressionStatement: function(o) {
      return this.asStatement(this.print(this.expression, o), o);
    },
    AssignmentExpression: function(o) {
      var fragments;
      fragments = [];
      fragments.push(...this.print(this.left, o));
      fragments.push(this.makeCode(` ${this.operator} `));
      fragments.push(...this.print(this.right, o));
      return fragments;
    },
    // @wrapInParensIfAbove(LEVEL_LIST) fragments, o
    Identifier: function(o) {
      return [this.makeCode(this.name)];
    },
    NumericLiteral: function(o) {
      return [this.makeCode(this.extra.raw)];
    },
    StringLiteral: function(o) {
      return [this.makeCode(this.extra.raw)];
    },
    CallExpression: function(o) {
      var arg, fragments, i, index, len, ref;
      fragments = [];
      fragments.push(...this.print(this.callee, o));
      fragments.push(this.makeCode('('));
      ref = this.arguments;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        arg = ref[index];
        if (index) {
          fragments.push(this.makeCode(', '));
        }
        fragments.push(...this.print(arg, o));
      }
      fragments.push(this.makeCode(')'));
      return fragments;
    },
    FunctionExpression: function(o) {
      var fragments, i, index, len, param, ref;
      fragments = [];
      fragments.push(this.makeCode('function'));
      fragments.push(this.makeCode('('));
      ref = this.params;
      for (index = i = 0, len = ref.length; i < len; index = ++i) {
        param = ref[index];
        if (index) {
          fragments.push(this.makeCode(', '));
        }
        fragments.push(...this.print(param, o));
      }
      fragments.push(this.makeCode(')'));
      fragments.push(this.makeCode(' '));
      fragments.push(...this.print(this.body, o));
      return fragments;
    },
    BlockStatement: function(o) {
      var body, fragments;
      fragments = [];
      o = indent(o);
      fragments.push(this.makeCode('{'));
      body = this.printStatementSequence(this.body, o);
      if (body.length) {
        fragments.push(this.makeCode('\n'));
      }
      fragments.push(...body);
      fragments.push(this.makeCode('}'));
      return fragments;
    },
    ReturnStatement: function(o) {
      var fragments;
      fragments = [this.makeCode('return')];
      if (this.argument) {
        fragments.push(this.makeCode(' '), ...this.print(this.argument, o));
      }
      return this.asStatement(fragments, o);
    },
    MemberExpression: function(o) {
      var fragments, property;
      fragments = [];
      fragments.push(...this.print(this.object, o));
      property = this.print(this.property, o);
      if (this.computed) {
        fragments.push(this.makeCode('['), ...property, this.makeCode(']'));
      } else {
        fragments.push(this.makeCode('.'), ...property);
      }
      return fragments;
    },
    BooleanLiteral: function(o) {
      return [this.makeCode(this.value ? 'true' : 'false')];
    }
  };

  makeCode = function(code) {
    return new CodeFragment(this, code);
  };

  nodePrint = function(node, o) {
    var printed;
    node.parent = this;
    printed = print(node, o);
    if (!needsParens(node, o)) {
      return printed;
    }
    return [node.makeCode('('), ...printed, node.makeCode(')')];
  };

  exports.print = print = function(node, o) {
    extend(node, {
      makeCode,
      printStatementSequence,
      wrapInParensIfAbove,
      asStatement,
      print: nodePrint
    });
    if (!printer[node.type]) {
      // node.tab = o.indent
      dump({
        missing: node
      });
    }
    return printer[node.type].call(node, o);
  };

  indent = function(o) {
    return merge(o, {
      indent: o.indent + TAB
    });
  };

  TAB = '  ';

  // Levels indicate a node's position in the AST. Useful for knowing if
  // parens are necessary or superfluous.
  LEVEL_TOP = 1; // ...;

  LEVEL_PAREN = 2; // (...)

  LEVEL_LIST = 3; // [...]

  LEVEL_COND = 4; // ... ? x : y

  LEVEL_OP = 5; // !...

  LEVEL_ACCESS = 6; // ...[0]

  needsParens = function(node, o) {
    var parent, type;
    ({type, parent} = node);
    if (o.front && (type === 'FunctionExpression')) {
      return true;
    }
    switch (type) {
      case 'AssignmentExpression':
        switch (parent.type) {
          case 'ReturnStatement':
            return true;
        }
    }
  };

  dump = function(obj) {
    return _dump(merge(obj, {
      parent: null
    }));
  };

}).call(this);
