don't apply:
prefer-const
no-const-assign
func-style
eqeqeq
prefer-arrow-callback
arrow-body-style
no-var
one-var
no-void
sort-vars
no-octal (we throw an error on unprefixed octal literal)
no-octal-escape (we throw an error on octal escape sequence)
func-names
no-ternary
init-declarations
import/no-mutable-export (since you can't control whether an exported member is const - might be nice to implement its "possible future behavior" of checking whether it in fact does get reassigned?)
no-label-var
no-extra-label
no-unused-labels
no-labels
no-with
no-fallthrough
no-undef-init
no-undefined
require-await
require-yield
no-dupe-args
getter-return (could be used for Object.defineProperty() calls?)
func-name-matching
no-func-assign
max-statements-per-line
no-mixed-requires
no-redeclare
for-direction
no-shadow-restricted-names
no-case-declarations
no-lone-blocks
curly
wrap-iife
template-tag-spacing
switch-colon-spacing
semi
semi-spacing
semi-style

usable against CS AST:
spaced-comment
no-warning-comments
capitalized-comments
prefer-rest-params
id-length
no-multi-assign
no-continue
prefer-destructuring
no-plusplus (allowForLoopAfterthoughts is meaningless)
no-underscore-dangle
no-throw-literal
prefer-spread
no-eval
no-implied-eval
prefer-template
new-cap
no-debugger
no-proto
no-dupe-keys
radix
symbol-description
no-new-symbol
no-useless-rename
no-console
no-bitwise
no-sparse-arrays
no-obj-calls
no-alert
no-new-object
handle-callback-err
no-useless-concat
no-iterator
no-param-reassign
no-new-func
no-useless-constructor
import/no-webpack-loader-syntax
no-duplicate-imports
import/prefer-default-export
no-new
prefer-numeric-literals
no-empty-character-class
no-path-concat
no-restricted-imports
no-restricted-globals
no-empty-pattern
no-invalid-regexp
no-caller
no-new-wrappers
no-script-url
no-extend-native
max-params
prefer-promise-reject-errors
id-blacklist
no-useless-call
no-array-constructor
no-prototype-builtins
no-useless-computed-key
global-require
no-restricted-syntax
no-restricted-properties
no-unsafe-finally
no-sync
no-process-env
no-restricted-modules
sort-imports
max-statements
max-lines
sort-keys
max-nested-callbacks
no-duplicate-case
no-process-exit
no-ex-assign
constructor-super
no-new-require
no-buffer-constructor
no-inline-comments
callback-return
no-use-before-define
no-class-assign
no-dupe-class-members
no-catch-shadow
no-empty
line-comment-position
linebreak-style
no-delete-var

partially usable against CS AST:
no-else-return (since we conflate else [nested if] with else if, can't currently just disallow the former)

customized for CS AST:
use-isnan
no-self-compare
no-eq-null (just the error message)
valid-typeof
no-negated-condition
yoda
no-unused-vars
no-undef
dot-notation
no-compare-neg-zero
camelcase (not really customized, just including a bugfix eslint/eslint#10802)
object-shorthand
no-extra-boolean-cast
no-regex-spaces
no-implicit-coercion
no-magic-numbers
no-self-assign
operator-assignment
no-unreachable
no-await-in-loop
class-methods-use-this
no-constant-condition
no-unused-expressions
no-template-curly-in-string
no-unneeded-ternary
no-unmodified-loop-condition
max-depth
vars-on-top
guard-for-in
no-useless-return
prefer-object-spread

not usable against CS AST:
no-sequences (we use SequenceExpressions eg when you use a block where an expression is expected - if included, this rule should be about use of ; operator I'd think)

usable:
array-callback-return (this is mostly trivially, as we implicitly return something - could presumably support allowImplicit: false checking once code path analysis works)

no-this-before-super (we catch this references before super(), but this catches eg super.foo() called before super())
no-cond-assign (except except-parens exception doesn't work, since it looks for double-parens)
no-control-regex (works but doesn't catch eg ///\x1f#{a}/// because compiles into template string - is that a bug in our compilation or does the rule not handle template strings?)
no-inner-declarations (trivially, since again don't think we generate named functions, and we always declare vars at top-level)
no-irregular-whitespace (can catch inside eg templates depending on which options are enabled)
no-unsafe-negation
valid-jsdoc (doesn't break, but doesn't seem to pick up JSDoc comments so doesn't do anything)
accessor-pairs (works for Object.defineProperty() calls, and for backticked objects with accessors)
block-scoped-var (trivially, since we always hoist var declarations)
complexity
default-case (but there doesn't seem to be an easy way to generate an empty default case, nor does the // do nothing comment currently get correctly positioned to get picked up)
no-div-regex
no-empty-function (however, it doesn't seem currently easy/possible to place a comment inside an empty function body, so not very useful)
no-extra-bind
no-global-assign (not sure I understand this rule, but I think the fact that we always generate declarations for assigned variables means that it can't be violated)
no-implicit-globals (trivially, I think - seems like it'd depend on whether compiled with bare and whether it should be sourceType: 'module')
no-invalid-this (but you can't generate eg function Foo(), Foo = -> @ will fail)
no-multi-str (trivially, doesn't seem to be able to trigger on multiline regular or heredoc strings)
consistent-this
no-lonely-if (trivially, since now generate else if when else clause is just an if statement)

need visibility of top-level ast.comments (should be doable to "hoist" comments just for eslint):
multiline-comment-style (can't run against CS AST since it looks for eg generated * in block comments)

not working:
require-jsdoc

not usable against JS AST (could get triggered by generated code):
import/first (since var declarations get generated before imports - this seems fixable? absolute-first works)
no-return-await (we generate return await when await is the last statement in a function, should we not?)
id-match (we generate vars that may not match the specified name pattern)
lines-between-class-members (we generate constructors with fake location data)
no-shadow (do (x) -> construct gets flagged, as does what we generate for classes eg A = class A)
padding-line-between-statements (we generate statements with fake location data)
no-return-assign (except-parens doesn't always work, since the closing paren can get stomped on by the OUTDENT that's assigned the same location data. also, this doesn't distinguish implicit from explicit returns. also, we generate assignments that could get included in implicit/explicit return, eg a[b] ? c)
consistent-return (eg a function ending with an if statement and no else generates an explicit return value inside the if and no corresponding return outside the if)
no-loop-func (we generate a nested closure function when you have nested for loops as an expression)
no-useless-escape (though prettier strips them from the output - we seem to generate "useless" escapes in regexes)

not usable but not meaningful:
no-nested-ternary (we generate nested ternaries in expression if/else if constructs, but you can't explicitly write ternaries so never would catch anything useful)
strict (I think we test that our generated JS follows strict mode semantics? how does it relate to sourceType: 'module'?)
