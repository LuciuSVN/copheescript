valid-typeof
prefer-const (trivially, since only looks for let)
no-const-assign (trivially, since we don't generate const)
no-new-object
object-shorthand properties
array-callback-return
prefer-template
no-useless-concat
no-eval
no-implied-eval
no-useless-escape (though prettier strips them from the output)
func-style (trivially, since we only output function expressions I think)
no-loop-func
no-new-func
no-param-reassign
no-useless-constructor
no-dupe-class-members
no-duplicate-imports
import/prefer-default-export
import/no-webpack-loader-syntax
no-iterator
no-restricted-syntax (depending on what AST types are disallowed, we may generate them, but looks like airbnb blacklist are not generated)
dot-notation
no-restricted-properties (like no-restricted-syntax, depending on what's disallowed we may generate it)
no-undef
no-plusplus (only if allowForLoopAfterthoughts is on, since we generate ++/-- in for loops)
eqeqeq (only if null: ignore or smart (ie not just always), since we generate != null in existence checks)
no-case-declarations (trivially, as it seems impossible to generate a declaration inside a case)
no-unneeded-ternary (perhaps confusing naming since in the source it's an if rather than a ternary, but works)
no-new-wrappers
radix
new-cap
no-underscore-dangle
no-restricted-globals
constructor-super (we catch some of these up front, but this works for eg missing super() in derived class constructor)
no-class-assign (mostly useless (won't catch reassignment of class name at same level) since we always generate an assignment for named classes - not sure why we do that, if we didn't then this rule could presumably catch reassignments? But this can catch eg reassignment of class name inside class method)
no-new-symbol
no-restricted-imports
no-this-before-super (we catch this references before super(), but this catches eg super.foo() called before super())
no-useless-computed-key
no-useless-rename
prefer-numeric-literals
require-yield (trivially, since we only generate generators based on presence of yield)
require-await (trivially, since we only generate async based on presence of await)
sort-imports
symbol-description
for-direction (trivially, as we typically generate the for loop direction - seems like it could in theory catch eg a for [10..1] by 2 but guessing it just looks at ++/-- rather than +=?)
getter-return (works for Object.defineProperty() calls or if you backtick the object/class getter syntaxes)
no-await-in-loop
no-compare-neg-zero
no-cond-assign (except except-parens exception doesn't work, since it looks for double-parens)
no-console
no-constant-condition
no-control-regex (works but doesn't catch eg ///\x1f#{a}/// because compiles into template string - is that a bug in our compilation or does the rule not handle template strings?)
no-debugger
no-dupe-args (trivially, as we catch duplicate parameters)
no-dupe-keys
no-duplicate-case
no-empty (with allowEmptyCatch option, since we generate empty catch block when just a try is specified - not sure if we generate empty blocks elsewhere? This rule seems not super valuable as afaik it's not easy to create empty blocks in Coffeescript)
no-empty-character-class
no-ex-assign (trivially, as we seem to always generate an error variable and then assign it to the specified var - so can't use this rule to achieve what it's meant to achieve)
no-extra-boolean-cast
no-func-assign (trivially, since I don't think we ever generate named functions)
no-inner-declarations (trivially, since again don't think we generate named functions, and we always declare vars at top-level)
no-invalid-regexp
no-irregular-whitespace (can catch inside eg templates depending on which options are enabled)
no-obj-calls
no-prototype-builtins
no-regex-spaces
no-sparse-arrays
no-template-curly-in-string (though not super helpful, as Coffeescript has a different interpolation syntax)
no-unreachable
no-unsafe-finally
no-unsafe-negation
use-isnan (trivially, since you can't generate a literal NaN)
valid-jsdoc (doesn't break, but doesn't seem to pick up JSDoc comments so doesn't do anything)
accessor-pairs (works for Object.defineProperty() calls, and for backticked objects with accessors)
block-scoped-var (trivially, since we always hoist var declarations)
class-methods-use-this
complexity
consistent-return
default-case (but there doesn't seem to be an easy way to generate an empty default case, nor does the // do nothing comment currently get correctly positioned to get picked up)
guard-for-in
no-alert
no-caller
no-div-regex
no-empty-function (however, it doesn't seem currently easy/possible to place a comment inside an empty function body, so not very useful)
no-empty-pattern (though doesn't catch [] = foo, since we compile that to just foo)
no-extend-native
no-extra-bind
no-extra-label (trivially, as I think it's impossible to generate a labeled statement (or label) in Coffeescript)
no-fallthrough (trivially, this is built into Coffeescript since it generates case break/return for us)
no-global-assign (not sure I understand this rule, but I think the fact that we always generate declarations for assigned variables means that it can't be violated)
no-implicit-coercion (though may depend on options if we generate unary + (not sure)?)
no-implicit-globals (trivially, I think - seems like it'd depend on whether compiled with bare and whether it should be sourceType: 'module')
no-invalid-this (but you can't generate eg function Foo(), Foo = -> @ will fail)
no-labels (trivially, since you can't create labels in Coffeescript)
no-lone-blocks (trivially, since afaik you can't create "standalone" blocks in Coffeescript)
no-multi-str (trivially, doesn't seem to be able to trigger on multiline regular or heredoc strings)
no-new
no-octal (trivially, since we throw an error on unprefixed octal literal)
no-octal-escape (trivially, since we throw an error on octal escape sequence)
no-proto
no-redeclare (trivially, since you can't generate multiple var declarations of the same variable. builtinGlobals doesn't seem to work eg top-level Object = 1, probably has to do with bare compilation?)
no-return-assign (except-parens doesn't always work, since the closing paren can get stomped on by the OUTDENT that's assigned the same location data. also, this doesn't distinguish implicit from explicit returns)
no-script-url
no-self-assign (looks like as opposed to no-self-compare, this uses AST comparison rather than token comparison)
no-throw-literal
no-unmodified-loop-condition
no-unused-expressions
no-unused-labels (trivially, since you can't create labels in Coffeescript)
no-useless-call (I don't think we generate any "useless" .call()/.apply()'s?)
no-useless-return (looks like this can't trigger, as we don't generate "useless" returns)
no-with (trivially, as Coffeescript doesn't support with statements)
prefer-promise-reject-errors
vars-on-top (not sure in what cases we put things before var declarations in a block?)
no-delete-var (mostly trivially, as we throw an error when deleting an existing var, but this can catch delete of var that's not yet been seen)
no-label-var (trivially, since you can't create labels)
no-shadow-restricted-names (trivially, since we flag attempts to assign to any of the restricted names)
no-undef-init (trivially, since we don't generated initialized var declarations)
no-undefined (trivially, since we generate void 0 for undefined and don't allow assigning to undefined)
no-unused-vars
no-catch-shadow (trivially, we always generate a free error variable, so would never trigger)
camelcase
consistent-this
func-name-matching (looks like this trivially works since it only looks for named functions (which we never generate), but it's conceptually irrelevant for Coffeescript since you can't "name" a function)
id-blacklist
max-depth
max-lines (though seems like it's off by one)
max-nested-callbacks
max-params
no-array-constructor
no-bitwise
no-lonely-if (trivially, since now generate else if when else clause is just an if statement)
operator-assignment (but can't use never setting, since we generate += in for with step)
sort-keys (I don't think we generate objects/object properties?)
callback-return
global-require
handle-callback-err
no-buffer-constructor
no-mixed-requires (trivially, since we don't typically generate initialized declarations)
no-new-require
no-path-concat
no-process-env
no-process-exit
no-restricted-modules
no-sync

need visibility of top-level ast.comments (should be doable to "hoist" comments just for eslint):
spaced-comment
no-warning-comments
capitalized-comments
line-comment-position
multiline-comment-style
no-inline-comments
require-jsdoc

not usable (could get triggered by generated code):
prefer-rest-params (we could presumably get rid of our generate uses of arguments to free up this rule)
import/no-mutable-export (since you can't control whether an exported member is const)
import/first (since var declarations get generated before imports - this seems fixable? absolute-first works)
yoda (we generate for loop conditions that violate - should be fixable)
no-else-return (we generate if { return } else { return } when making if return - would be nice to support this)
id-length (eg for loops generate one-character variable names)
no-multi-assign (eg for loops can generate multi-assigns)
no-self-compare (seems to rely on location data, so generated comparisons with identical location data on each side can trigger this, eg y.z?.a)
prefer-destructuring (we generate eg indexOf = [].indexOf - this seems like we could change to allow this useful rule)
no-sequences (we generate sequences)
no-eq-null (we generate != null as part of existence checks)
no-magic-numbers (seems like the assignment of the magic number to a var is always flagged since it's not part of the variable declaration)
no-return-await (we generate return await when await is the last statement in a function, should we not?)
no-use-before-define (this gets confused by location data of generated constructs)
id-match (we generate vars that may not match the specified name pattern)
lines-between-class-members (we generate constructors with fake location data)
no-shadow (do (x) -> construct gets flagged, as does what we generate for classes eg A = class A)
max-statements (generated var declarations get counted)
max-statements-per-line
no-continue (we generate continue statements as part of for when guard)
no-negated-condition (unless generates a negated condition)
padding-line-between-statements (we generate statements with fake location data)

not sure if it could get triggered by generated code:
prefer-spread (works on manual .apply(), wasn't able to trigger it in simple check of generated .apply(), if it does get triggered by generated .apply()'s, could presumably get rid of generated .apply()'s)

not usable but not meaningful:
no-var
object-shorthand methods (we don't generate method shorthand)
prefer-arrow-callback
arrow-body-style
one-var
no-nested-ternary (we generate nested ternaries in expression if/else if constructs, but you can't explicitly write ternaries so never would catch anything useful)
no-void (we generate void 0 for undefined, but you can't explicitly write void)
strict (I think we test that our generated JS follows strict mode semantics? how does it relate to sourceType: 'module'?)
init-declarations (we generate all declarations, typically unininitialized)
func-names (we never generate named functions)
linebreak-style (I think? not sure how prettier generates linebreaks/why this isn't in eslint-config-prettier)
no-ternary (we generate ternary for if expressions)
sort-vars (we generated alphabetized var declarations but put initialized last)
